// @flow
import type { Dispatch } from 'redux'

export type Action = {
  type: string,
  meta?: any,
  payload?: any,
  error?: any
}

export type Validator = (
  value: any,
  allValues: Object,
  props: Object,
  name: string
) => ?any

export interface Structure<M, L> {
  allowsArrayErrors: boolean;
  empty: M;
  emptyList: L;
  getIn(state: any, field: string): any;
  setIn(state: any, field: string, value: any): any;
  deepEqual(a: any, b: any): boolean;
  deleteIn(state: any, field: string): any;
  forEach(list: L, callback: { (item: any, index: number): void }): void;
  fromJS(value: any): any;
  keys(value: M): L;
  size(array: L): number;
  some(list: L, callback: { (item: any, index: number): boolean }): boolean;
  splice(array: L, index: number, removeNum: number, value: any): L;
  equals(a: any, b: any): boolean;
  orderChanged(a: any, b: any): boolean;
  toJS(value: M): any;
}

export type FieldType = 'Field' | 'FieldArray'

export type Values = any

export type GetFormState = { (state: any): any }

export type Option = {
  selected: boolean,
  value: any
}

/*
 * React-DOM's default typing of drag and focus events is built for the general case, where the target is not necessarily
 * an HTMLInputElement. They can be specialized with a type parameter, but that only affects the currentTarget element,
 * not the target. We should maybe be using currentTarget internally, but for backwards-compatibility's sake we'll extend
 * these to specify that the target is what we expect
 *
 * "Optimistic" because we're being optimistic about the browser always doing what we expect
 */
export interface OptimisticSyntheticDragEvent extends SyntheticDragEvent<HTMLInputElement> {
  target: HTMLInputElement
}

export interface OptimisticSyntheticFocusEvent extends SyntheticFocusEvent<HTMLInputElement> {
  target: HTMLInputElement
}

export type Event = SyntheticInputEvent<> | OptimisticSyntheticDragEvent | OptimisticSyntheticFocusEvent

export type Context = {
  form: string,
  getFormState: GetFormState,
  asyncValidate: {
    (name: ?string, value: ?any, trigger: 'blur' | 'change'): Promise<any>
  },
  getValues: { (): Object },
  sectionPrefix?: string,
  prefixName?: string,
  register: (
    name: string,
    type: string,
    getValidator: ?() => ?(Validator | Validator[]),
    getWarner: ?() => ?(Validator | Validator[])
  ) => void,
  unregister: (name: string) => void,
  registerInnerOnSubmit: (innerOnSubmit: Function) => void,
  focus: (name: string) => void,
  change: (name: string, value: any) => void,
  blur: (name: string, value: any) => void
}

export type ReactContext = {
  _reduxForm: Context
}

export type SubmitFunction = (
  values: any,
  dispatch: Dispatch<any>,
  props: Object
) => any

type HandleSubmit = (event: ?Event) => void | Promise<any>

export type FormProps = {
  anyTouched: boolean,
  array: {
    insert: (field: string, index: number, value: any) => void,
    move: (field: string, from: number, to: number) => void,
    pop: (field: string) => void,
    push: (field: string, value: any) => void,
    remove: (field: string, index: number) => void,
    removeAll: (field: string) => void,
    shift: (field: string) => void,
    splice: (
      field: string,
      index: number,
      removeNum: number,
      value: any
    ) => void,
    swap: (field: string, indexA: number, indexB: number) => void,
    unshift: (field: string, value: any) => void
  },
  asyncValidate: () => void,
  asyncValidating: string | boolean,
  autofill: (field: string, value: any) => void,
  blur: (field: string, value: any) => void,
  change: (field: string, value: any) => void,
  clearAsyncError: (field: string) => void,
  clearSubmit: () => void,
  destroy: () => void,
  dirty: boolean,
  dispatch: Function,
  error: any,
  form: string,
  handleSubmit: HandleSubmit & (SubmitFunction => HandleSubmit), // '&' (intersection type) means function overloading
  initialize: (data: Object) => void,
  initialized: boolean,
  initialValues: Object,
  invalid: boolean,
  pristine: boolean,
  reset: () => void,
  resetSection: () => void,
  submitting: boolean,
  submitFailed: boolean,
  submitSucceeded: boolean,
  touch: (...fields: string[]) => void,
  untouch: (...fields: string[]) => void,
  valid: boolean,
  warning: any
}
